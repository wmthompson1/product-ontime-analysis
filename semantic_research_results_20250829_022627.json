{
  "timestamp": "2025-08-29T02:26:27.799729",
  "test_results": [
    {
      "test_id": "supply_chain_001",
      "domain": "supply_chain",
      "query": "Show suppliers with delivery performance below 95% affecting production schedule",
      "generated_sql": "```sql SELECT s.supplier_id, s.supplier_name, AVG(dd.ontime_rate) AS average_ontime_rate FROM SUPPLIERS s JOIN DAILY_DELIVERIES dd ON s.supplier_id = dd.supplier_id GROUP BY s.supplier_id, s.supplier_name HAVING AVG(dd.ontime_rate) < %s; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query joins the SUPPLIERS and DAILY_DELIVERIES tables on the supplier_id field. It then groups the results by supplier_id and supplier_name, and calculates the average ontime_rate for each supplier. The HAVING clause filters out suppliers with an average ontime_rate of 95% or higher, leaving only those with an average ontime_rate below 95%.",
      "safety_check": true,
      "quality_score": 0.4,
      "concept_coverage": 0.25,
      "contextual_hints_count": 3,
      "acronyms_detected": 2,
      "timestamp": "2025-08-29T02:25:42.451171"
    },
    {
      "test_id": "quality_001",
      "domain": "quality_control",
      "query": "Find products with NCM rates trending above industry standards",
      "generated_sql": "```sql WITH industry_standard AS ( SELECT benchmark_value FROM INDUSTRY_BENCHMARKS WHERE metric_name = 'NCM Rate' ), ncm_trend AS ( SELECT pd.product_line, AVG(pd.defect_rate) AS avg_defect_rate FROM PRODUCT_DEFECTS pd WHERE pd.defect_type = 'NCM' GROUP BY pd.product_line ) SELECT ncm_trend.product_line, ncm_trend.avg_defect_rate FROM ncm_trend, industry_standard WHERE ncm_trend.avg_defect_rate > industry_standard.benchmark_value; ```",
      "confidence": 0.9,
      "complexity": "QueryComplexity.MEDIUM",
      "explanation": " This query first creates a subquery (industry_standard) to get the industry standard for NCM Rate from the INDUSTRY_BENCHMARKS table. Then, it creates another subquery (ncm_trend) to calculate the average defect rate for each product line from the PRODUCT_DEFECTS table where the defect type is 'NCM'. Finally, it selects the product lines from the ncm_trend subquery where the average defect rate is greater than the industry standard. The join strategy here is a cross join between the two subqueries. Since the industry_standard subquery should only return one row (the industry standard for NCM Rate), this effectively filters the rows from the ncm_trend subquery based on the industry standard. Performance should be reasonable assuming the number of product lines and the number of rows in the INDUSTRY_BENCHMARKS table are not excessively large. If performance is an issue, consider adding indexes on the PRODUCT_DEFECTS.defect_type and INDUSTRY_BENCHMARKS.metric_name columns.",
      "safety_check": true,
      "quality_score": 0.35000000000000003,
      "concept_coverage": 1.0,
      "contextual_hints_count": 5,
      "acronyms_detected": 5,
      "timestamp": "2025-08-29T02:25:55.899907"
    },
    {
      "test_id": "production_001",
      "domain": "production_efficiency",
      "query": "Calculate OEE for critical equipment showing downtime patterns",
      "generated_sql": "```sql WITH critical_equipment AS ( SELECT equipment_id, equipment_name, measurement_date, availability_rate * performance_rate * quality_rate AS oee, downtime_hours FROM equipment_metrics WHERE equipment_type = %s ) SELECT equipment_id, equipment_name, measurement_date, oee, downtime_hours, LAG(downtime_hours) OVER (PARTITION BY equipment_id ORDER BY measurement_date) AS previous_downtime, downtime_hours - LAG(downtime_hours) OVER (PARTITION BY equipment_id ORDER BY measurement_date) AS downtime_difference FROM critical_equipment ORDER BY equipment_id, measurement_date; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query first creates a temporary table (critical_equipment) that selects the equipment_id, equipment_name, measurement_date, OEE (calculated as the product of availability_rate, performance_rate, and quality_rate), and downtime_hours from the equipment_metrics table, but only for rows where the equipment_type is 'Critical'. Then, from this temporary table, it selects all columns and also calculates the previous_downtime (the downtime_hours from the previous row for the same equipment_id, ordered by measurement_date) and the downtime_difference (the difference between the current and previous downtime_hours). The final result is ordered by equipment_id and measurement_date.",
      "safety_check": true,
      "quality_score": 0.30000000000000004,
      "concept_coverage": 1.0,
      "contextual_hints_count": 2,
      "acronyms_detected": 2,
      "timestamp": "2025-08-29T02:26:04.940107"
    },
    {
      "test_id": "maintenance_001",
      "domain": "maintenance",
      "query": "Show equipment with MTBF below target requiring immediate attention",
      "generated_sql": "```sql SELECT em.equipment_id, em.equipment_name, er.mtbf_hours, mt.target_mtbf FROM EQUIPMENT_METRICS em JOIN EQUIPMENT_RELIABILITY er ON em.equipment_id = er.equipment_id JOIN MAINTENANCE_TARGETS mt ON em.equipment_type = mt.equipment_type WHERE er.mtbf_hours < mt.target_mtbf; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query joins the EQUIPMENT_METRICS, EQUIPMENT_RELIABILITY, and MAINTENANCE_TARGETS tables on the appropriate keys. It then filters the results to only include rows where the Mean Time Between Failures (MTBF) is less than the target MTBF. This will return a list of equipment that is failing more frequently than desired and may require immediate attention.",
      "safety_check": true,
      "quality_score": 0.45000000000000007,
      "concept_coverage": 1.0,
      "contextual_hints_count": 2,
      "acronyms_detected": 2,
      "timestamp": "2025-08-29T02:26:13.372466"
    },
    {
      "test_id": "compliance_001",
      "domain": "compliance",
      "query": "Analyze CAPA effectiveness for recurring quality issues",
      "generated_sql": "```sql WITH recurring_issues AS ( SELECT ncm_id, COUNT(*) AS recurrence_count FROM non_conformant_materials GROUP BY ncm_id HAVING COUNT(*) > 1 ), capa_effectiveness AS ( SELECT ca.ncm_id, AVG(ca.effectiveness_score) AS avg_effectiveness FROM corrective_actions ca INNER JOIN recurring_issues ri ON ca.ncm_id = ri.ncm_id GROUP BY ca.ncm_id ) SELECT ncm.product_line, ncm.failure_mode, ncm.root_cause, ri.recurrence_count, ce.avg_effectiveness FROM non_conformant_materials ncm INNER JOIN recurring_issues ri ON ncm.ncm_id = ri.ncm_id INNER JOIN capa_effectiveness ce ON ncm.ncm_id = ce.ncm_id ORDER BY ce.avg_effectiveness DESC; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query first identifies recurring quality issues by counting the number of times each NCM incident occurs (recurring_issues). Then, it calculates the average effectiveness of the corrective actions for each recurring issue (capa_effectiveness). Finally, it joins these results with the non_conformant_materials table to provide details about each recurring issue, including the product line, failure mode, root cause, recurrence count, and average CAPA effectiveness. The results are ordered by average CAPA effectiveness in descending order.",
      "safety_check": true,
      "quality_score": 0.55,
      "concept_coverage": 1.0,
      "contextual_hints_count": 4,
      "acronyms_detected": 3,
      "timestamp": "2025-08-29T02:26:27.799598"
    }
  ],
  "summary_statistics": {
    "total_tests": 5,
    "successful_tests": 5,
    "success_rate": 1.0,
    "average_quality": 0.41,
    "average_confidence": 0.9800000000000001,
    "average_concept_coverage": 0.85,
    "total_acronyms_detected": 14,
    "safety_compliance": 1.0
  },
  "domain_analysis": {
    "supply_chain": {
      "count": 1,
      "quality_scores": [
        0.4
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        0.25
      ],
      "avg_quality": 0.4,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 0.25
    },
    "quality_control": {
      "count": 1,
      "quality_scores": [
        0.35000000000000003
      ],
      "confidence_scores": [
        0.9
      ],
      "concept_coverage": [
        1.0
      ],
      "avg_quality": 0.35000000000000003,
      "avg_confidence": 0.9,
      "avg_concept_coverage": 1.0
    },
    "production_efficiency": {
      "count": 1,
      "quality_scores": [
        0.30000000000000004
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        1.0
      ],
      "avg_quality": 0.30000000000000004,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 1.0
    },
    "maintenance": {
      "count": 1,
      "quality_scores": [
        0.45000000000000007
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        1.0
      ],
      "avg_quality": 0.45000000000000007,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 1.0
    },
    "compliance": {
      "count": 1,
      "quality_scores": [
        0.55
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        1.0
      ],
      "avg_quality": 0.55,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 1.0
    }
  },
  "research_insights": [
    "High success rate indicates robust SQL generation capabilities",
    "SQL quality could be improved through better domain knowledge integration",
    "Strong business concept coverage in generated queries",
    "Strongest performance in compliance domain (quality: 0.55)",
    "Contextual hints successfully detected 14 manufacturing acronyms"
  ]
}