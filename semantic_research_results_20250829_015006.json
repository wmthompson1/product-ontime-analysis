{
  "timestamp": "2025-08-29T01:50:06.283330",
  "test_results": [
    {
      "test_id": "supply_chain_001",
      "domain": "supply_chain",
      "query": "Show suppliers with delivery performance below 95% affecting production schedule",
      "generated_sql": "```sql SELECT s.supplier_id, s.supplier_name, AVG(d.ontime_rate) AS average_ontime_rate FROM SUPPLIERS s JOIN DAILY_DELIVERIES d ON s.supplier_id = d.supplier_id GROUP BY s.supplier_id, s.supplier_name HAVING AVG(d.ontime_rate) < %s; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query joins the SUPPLIERS and DAILY_DELIVERIES tables on the supplier_id field. It then groups the results by supplier_id and supplier_name, and calculates the average ontime_rate for each supplier. The HAVING clause filters out any suppliers with an average ontime_rate of 95% or higher, leaving only those suppliers with a delivery performance below 95%.",
      "safety_check": true,
      "quality_score": 0.4,
      "concept_coverage": 0.75,
      "contextual_hints_count": 3,
      "acronyms_detected": 2,
      "timestamp": "2025-08-29T01:49:22.042556"
    },
    {
      "test_id": "quality_001",
      "domain": "quality_control",
      "query": "Find products with NCM rates trending above industry standards",
      "generated_sql": "```sql WITH defect_trends AS ( SELECT product_line, AVG(defect_rate) OVER (PARTITION BY product_line ORDER BY production_date ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS moving_average_defect_rate FROM PRODUCT_DEFECTS WHERE defect_type = %s ) SELECT p.id, p.description, dt.product_line, dt.moving_average_defect_rate FROM products p JOIN defect_trends dt ON p.description = dt.product_line WHERE dt.moving_average_defect_rate > %s; ```",
      "confidence": 0.9,
      "complexity": "QueryComplexity.MEDIUM",
      "explanation": " This query first creates a CTE (Common Table Expression) named 'defect_trends' that calculates the moving average of the defect rate for each product line, considering the current and the three preceding rows (this can be adjusted based on the desired trend period). This is done using the window function AVG() with an ORDER BY clause to ensure the rows are considered in chronological order. The PARTITION BY clause ensures that this calculation is done separately for each product line. The main query then joins the 'products' table with the 'defect_trends' CTE based on the product description and product line. The WHERE clause filters out the products whose moving average defect rate is not above the industry standard (2.5% in this case). This query assumes that the 'description' column in the 'products' table corresponds to the 'product_line' column in the 'PRODUCT_DEFECTS' table.",
      "safety_check": true,
      "quality_score": 0.4,
      "concept_coverage": 0.5,
      "contextual_hints_count": 5,
      "acronyms_detected": 5,
      "timestamp": "2025-08-29T01:49:38.977178"
    },
    {
      "test_id": "production_001",
      "domain": "production_efficiency",
      "query": "Calculate OEE for critical equipment showing downtime patterns",
      "generated_sql": "``` WITH critical_equipment AS ( SELECT e.equipment_id, e.date, e.availability * e.performance * e.quality AS oee, f.downtime_hours FROM equipment_metrics e LEFT JOIN failure_events f ON e.equipment_id = f.equipment_id AND e.date = f.failure_date WHERE e.equipment_type = %s ), downtime_pattern AS ( SELECT equipment_id, date, oee, SUM(downtime_hours) OVER (PARTITION BY equipment_id ORDER BY date) AS cumulative_downtime FROM critical_equipment ) SELECT * FROM downtime_pattern ORDER BY equipment_id, date; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query first creates a temporary table 'critical_equipment' that selects the equipment_id, date, OEE (calculated as the product of availability, performance, and quality), and downtime_hours from the 'equipment_metrics' table joined with the 'failure_events' table on equipment_id and date, for equipment of type 'Critical'. Then, it creates another temporary table 'downtime_pattern' that calculates the cumulative downtime for each equipment_id over time using a window function. Finally, it selects all records from the 'downtime_pattern' table and orders them by equipment_id and date.",
      "safety_check": true,
      "quality_score": 0.5,
      "concept_coverage": 1.0,
      "contextual_hints_count": 2,
      "acronyms_detected": 2,
      "timestamp": "2025-08-29T01:49:50.260827"
    },
    {
      "test_id": "maintenance_001",
      "domain": "maintenance",
      "query": "Show equipment with MTBF below target requiring immediate attention",
      "generated_sql": "```sql SELECT em.equipment_id, em.equipment_type, er.measurement_period, er.mtbf_hours, er.target_mtbf FROM EQUIPMENT_METRICS em JOIN EQUIPMENT_RELIABILITY er ON em.equipment_id = er.equipment_id WHERE er.mtbf_hours < er.target_mtbf; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query joins the EQUIPMENT_METRICS and EQUIPMENT_RELIABILITY tables on the equipment_id field. It then selects the equipment_id, equipment_type, measurement_period, mtbf_hours, and target_mtbf fields from the joined table. The WHERE clause filters the results to only include rows where the mtbf_hours (Mean Time Between Failures) is less than the target_mtbf. This will return the equipment that has a MTBF below the target, indicating that it requires immediate attention.",
      "safety_check": true,
      "quality_score": 0.35000000000000003,
      "concept_coverage": 0.75,
      "contextual_hints_count": 2,
      "acronyms_detected": 2,
      "timestamp": "2025-08-29T01:49:57.472176"
    },
    {
      "test_id": "compliance_001",
      "domain": "compliance",
      "query": "Analyze CAPA effectiveness for recurring quality issues",
      "generated_sql": "```sql WITH recurring_issues AS ( SELECT ncm_id, COUNT(*) AS recurrence_count FROM non_conformant_materials GROUP BY ncm_id HAVING COUNT(*) > 1 ), capa_effectiveness AS ( SELECT capa_id, ncm_id, effectiveness_score FROM corrective_actions WHERE ncm_id IN (SELECT ncm_id FROM recurring_issues) ) SELECT ncm_id, AVG(effectiveness_score) AS average_effectiveness FROM capa_effectiveness GROUP BY ncm_id ORDER BY average_effectiveness DESC; ```",
      "confidence": 1.0,
      "complexity": "QueryComplexity.SIMPLE",
      "explanation": " This query first identifies recurring quality issues by counting the number of times each NCM incident occurs in the non_conformant_materials table. It then selects the CAPA records associated with these recurring issues and calculates the average effectiveness score for each NCM incident. The result is a list of recurring NCM incidents sorted by the average effectiveness of their associated CAPA actions.",
      "safety_check": true,
      "quality_score": 0.5,
      "concept_coverage": 1.0,
      "contextual_hints_count": 4,
      "acronyms_detected": 3,
      "timestamp": "2025-08-29T01:50:06.283213"
    }
  ],
  "summary_statistics": {
    "total_tests": 5,
    "successful_tests": 5,
    "success_rate": 1.0,
    "average_quality": 0.43000000000000005,
    "average_confidence": 0.9800000000000001,
    "average_concept_coverage": 0.8,
    "total_acronyms_detected": 14,
    "safety_compliance": 1.0
  },
  "domain_analysis": {
    "supply_chain": {
      "count": 1,
      "quality_scores": [
        0.4
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        0.75
      ],
      "avg_quality": 0.4,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 0.75
    },
    "quality_control": {
      "count": 1,
      "quality_scores": [
        0.4
      ],
      "confidence_scores": [
        0.9
      ],
      "concept_coverage": [
        0.5
      ],
      "avg_quality": 0.4,
      "avg_confidence": 0.9,
      "avg_concept_coverage": 0.5
    },
    "production_efficiency": {
      "count": 1,
      "quality_scores": [
        0.5
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        1.0
      ],
      "avg_quality": 0.5,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 1.0
    },
    "maintenance": {
      "count": 1,
      "quality_scores": [
        0.35000000000000003
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        0.75
      ],
      "avg_quality": 0.35000000000000003,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 0.75
    },
    "compliance": {
      "count": 1,
      "quality_scores": [
        0.5
      ],
      "confidence_scores": [
        1.0
      ],
      "concept_coverage": [
        1.0
      ],
      "avg_quality": 0.5,
      "avg_confidence": 1.0,
      "avg_concept_coverage": 1.0
    }
  },
  "research_insights": [
    "High success rate indicates robust SQL generation capabilities",
    "SQL quality could be improved through better domain knowledge integration",
    "Strong business concept coverage in generated queries",
    "Strongest performance in production_efficiency domain (quality: 0.50)",
    "Contextual hints successfully detected 14 manufacturing acronyms"
  ]
}